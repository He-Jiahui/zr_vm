//
// Created by HeJiahui on 2025/6/19.
//

#ifndef ZR_INSTRUCTION_CONF_H
#define ZR_INSTRUCTION_CONF_H

#include "zr_vm_common/zr_type_conf.h"
#include "zr_vm_common/zr_common_conf.h"
#define ZR_INSTRUCTION_USE_DISPATCH_TABLE

#if defined(ZR_COMPILER_GNU) || defined(ZR_COMPILER_CLANG)
#define ZR_INSTRUCTION_DISPATCH_TABLE_SUPPORTED 1
#elif defined(ZR_COMPILER_MSVC)
#define ZR_INSTRUCTION_DISPATCH_TABLE_SUPPORTED 0
#endif


#define ZR_INSTRUCTION_DECLARE(Z)\
    Z(MOVE, 1)\
    Z(LOAD_CONSTANT, 2)\
    Z(ADD, 3)


#define ZR_INSTRUCTION_OPCODE(INSTRUCTION) (INSTRUCTION.instruction.operationCode)

#define ZR_INSTRUCTION_FETCH(INSTRUCTION, PC)\
    {\
        if (ZR_UNLIKELY(trap != ZR_DEBUG_SIGNAL_NONE)) { \
        /*todo:*/\
        }\
        INSTRUCTION = *(PC++);\
    }

#define ZR_INSTRUCTION_REGISTER_WRAP(WRAP_START, WRAP_END, ...)\
    WRAP_START\
        __VA_ARGS__\
    WRAP_END

#define ZR_INSTRUCTION_ENUM(INSTRUCTION)\
ZR_INSTRUCTION_OP_##INSTRUCTION

#define ZR_INSTRUCTION_ENUM_WRAP(...)\
    ZR_INSTRUCTION_REGISTER_WRAP(enum EZrInstructionCode{,ZR_INSTRUCTION_ENUM(ENUM_MAX)}, __VA_ARGS__)

#define ZR_INSTRUCTION_ENUM_DECLARE(INSTRUCTION, CONSTANT)\
    ZR_INSTRUCTION_ENUM(INSTRUCTION) = (CONSTANT),


#define ZR_INSTRUCTION_DISPATCH_TABLE_WRAP(...)\
    ZR_INSTRUCTION_REGISTER_WRAP(static const void* const CZrInstructionDispatchTable[ZR_INSTRUCTION_ENUM(ENUM_MAX)]={,}, __VA_ARGS__)

#define ZR_INSTRUCTION_DISPATCH_TABLE_DECLARE(INSTRUCTION, DISPATCH)\
    &&LZrInstruction_##INSTRUCTION,

#if defined(ZR_INSTRUCTION_USE_DISPATCH_TABLE) && ZR_INSTRUCTION_DISPATCH_TABLE_SUPPORTED
#define ZR_INSTRUCTION_DISPATCH_TABLE ZR_INSTRUCTION_DISPATCH_TABLE_WRAP(ZR_INSTRUCTION_DECLARE(ZR_INSTRUCTION_DISPATCH_TABLE_DECLARE));
#define ZR_INSTRUCTION_DISPATCH(INSTRUCTION) goto *CZrInstructionDispatchTable[ZR_INSTRUCTION_OPCODE(INSTRUCTION)];
#define ZR_INSTRUCTION_LABEL(INSTRUCTION) LZrInstruction_##INSTRUCTION:
#define ZR_INSTRUCTION_DONE(INSTRUCTION, PC) ZR_INSTRUCTION_FETCH(INSTRUCTION, PC) ZR_INSTRUCTION_DISPATCH(INSTRUCTION)
#else
#define ZR_INSTRUCTION_DISPATCH_TABLE ((void)0);
#define ZR_INSTRUCTION_DISPATCH(INSTRUCTION) switch (ZR_INSTRUCTION_OPCODE(INSTRUCTION))
#define ZR_INSTRUCTION_LABEL(INSTRUCTION) case ZR_INSTRUCTION_ENUM(INSTRUCTION):
#define ZR_INSTRUCTION_DONE(INSTRUCTION, PC) break;
#endif

// enum EZrOperationCode {
//     ZR_OPCODE_MOVE,
//     ZR_OPCODE_LOAD_CONSTANT,
//     // TODO:
//
//     // MATH OPERATION
//     ZR_OPCODE_ADD,
//     ZR_OPCODE_SUB,
//     ZR_OPCODE_MUL,
//     ZR_OPCODE_DIV,
//     ZR_OPCODE_MOD,
//     ZR_OPCODE_SHIFT_LEFT,
//     ZR_OPCODE_SHIFT_RIGHT,
//
//     ZR_OPCODE_LOGICAL_NOT,
//     ZR_OPCODE_LOGICAL_AND,
//     ZR_OPCODE_LOGICAL_OR,
//     ZR_OPCODE_LOGICAL_GREATER,
//     ZR_OPCODE_LOGICAL_LESS,
//     ZR_OPCODE_LOGICAL_EQUAL,
//     ZR_OPCODE_LOGICAL_NOT_EQUAL,
//     ZR_OPCODE_LOGICAL_GREATER_EQUAL,
//     ZR_OPCODE_LOGICAL_LESS_EQUAL,
//
//
//     ZR_OPCODE_BINARY_NOT,
//     ZR_OPCODE_BINARY_AND,
//     ZR_OPCODE_BINARY_OR,
//     ZR_OPCODE_BINARY_XOR,
//
//
//     ZR_OPCODE_ENUM_MAX
// };

// typedef enum EZrOperationCode EZrOperationCode;

ZR_INSTRUCTION_ENUM_WRAP(ZR_INSTRUCTION_DECLARE(ZR_INSTRUCTION_ENUM_DECLARE));

typedef enum EZrInstructionCode EZrInstructionCode;

struct SZrInstruction {
    EZrInstructionCode operationCode;
    TUInt8 operand[4];
};

typedef struct SZrInstruction SZrInstruction;

union TZrInstruction {
    SZrInstruction instruction;
    TUInt64 value;
};

typedef union TZrInstruction TZrInstruction;
#endif //ZR_INSTRUCTION_CONF_H
